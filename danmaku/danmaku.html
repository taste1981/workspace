<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danmaku PnP measurement page</title>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: white; display: flex; flex-direction: column; align-items: center; }
        .wpe-demo { width: 900px; margin: 20px auto; }
        
        #wpe-container__wrapper {
            width: 100%;
            height: 500px;
            position: relative;
            overflow: hidden;
            background: #000;
            border-radius: 8px;
        }
        
        #wpe-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.3s ease; /* Smooth fade when toggling */
        }
        
        /* Class to hide danmaku */
        .danmaku-hidden {
            opacity: 0 !important;
            visibility: hidden;
        }
        
        .wpe-barrage-item {
            position: absolute;
            top: 0;
            left: 100%;
            white-space: nowrap;
            font-weight: 900;
            font-size: 22px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            will-change: transform;
        }
        
        #video { width: 100%; height: 100%; display: block; }

        .wpe-manage {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .controls-row { width: 100%; display: flex; gap: 10px; align-items: center; }
        
        input { flex: 1; padding: 12px; border-radius: 4px; border: none; background: #333; color: white; }
        button { padding: 10px 15px; cursor: pointer; border-radius: 4px; border: none; background: #ff4757; color: white; font-weight: bold; transition: 0.2s; }
        button:hover { opacity: 0.8; }
        
        #toggle-btn { background: #535c68; }
        #clear-btn { background: #f0932b; }
        #fullscreen-btn { background: #2f3542; }

        .switch-label { display: flex; align-items: center; gap: 8px; font-size: 14px; cursor: pointer; }

        /* Density control */
        .density-label { min-width: 90px; font-size: 14px; color: #ddd; }
        #density { flex: 1; }
        #density-value { min-width: 28px; text-align: right; font-variant-numeric: tabular-nums; color: #fff; }

        /* Checkbox should not stretch like text inputs */
        .controls-row input[type="checkbox"] { flex: 0 0 auto; width: auto; }
        .hint { font-size: 12px; color: #bdbdbd; }
        .status { font-size: 12px; color: #9cdcfe; min-width: 140px; text-align: right; }
    </style>
</head>

<body>
    <h1>DANMAKU CONTROL CENTER</h1>
    <div class="wpe-demo">
        <div id="wpe-container__wrapper">
            <video id="video" src="video.mp4" controls loop></video>
            <div id="wpe-container"></div>
        </div>

        <div class="wpe-manage">
            <div class="controls-row">
                <input type="text" id="wpe-manage-input" placeholder="Type a message...">
                <button id="wpe-manage-btn">Emit</button>
            </div>
            <div class="controls-row">
                <button id="toggle-btn">Disable Danmaku</button>
                <button id="clear-btn">Clear Screen</button>
                <button id="fullscreen-btn">Fullscreen</button>
            </div>
            <div class="controls-row">
                <span class="density-label">Density</span>
                <input type="range" id="density" min="0" max="5" step="1" value="1" />
                <span id="density-value">1</span>
            </div>
            <div class="controls-row">
                <label class="switch-label" for="require-charging">
                    <input type="checkbox" id="require-charging" checked />
                    Require charging for high density
                </label>
                <span class="hint">(forces Density=1 when on battery)</span>
                <span class="status" id="battery-status"></span>
            </div>
        </div>
    </div>

    <script>
        class Barrage {
            static random(start, end) { return start + (Math.random() * (end - start)); }
            static animate(obj) {
                obj.distance -= obj.speed; 
                obj.divNode.style.transform = `translateX(${obj.distance}px)`;
                if (Math.abs(obj.distance) < obj.width + obj.left) {
                    obj.timer = requestAnimationFrame(() => Barrage.animate(obj));
                } else {
                    obj.destroy();
                }
            }
            constructor({text}) {
                this.text = text;
                this.speed = Barrage.random(3, 7);
                this.timer = null;
                this.divNode = null;
            }
            append(container) {
                const divNode = document.createElement('div');
                this.divNode = divNode;
                divNode.innerHTML = this.text;
                divNode.classList.add('wpe-barrage-item');
                const lanes = Math.floor(container.barrageWrapperHeight / 30); 
                const lane = Math.floor(Math.random() * lanes);
                divNode.style.top = `${(lane * 30) + 10}px`;
                divNode.style.color = container.barrageColorArray[Math.floor(Math.random() * container.barrageColorArray.length)];
                container.$container.appendChild(divNode);
                this.width = divNode.offsetWidth;
                this.left = container.barrageWrapperWidth;
                this.distance = 0;
                divNode.style.left = this.left + 'px';
                container.barrageArray.push(this);
                Barrage.animate(this);
            }
            destroy() {
                cancelAnimationFrame(this.timer);
                if (this.divNode && this.divNode.parentNode) this.divNode.parentNode.removeChild(this.divNode);
                container.barrageArray = container.barrageArray.filter(i => i !== this);
            }
        }

        class BarrageContainer {
            constructor(wrapperId, containerId) {
                this.$wrapper = document.querySelector(wrapperId);
                this.$container = document.querySelector(containerId);
                this.barrageArray = [];
                this.isEnabled = true; // State for disabling
                this.barrageColorArray = ['#ffffff', '#00ff00', '#ffff00', '#00ffff', '#ff69b4', '#ffa500', '#ff4757'];
                this.updateSize();
            }
            updateSize() {
                this.barrageWrapperWidth = this.$wrapper.offsetWidth;
                this.barrageWrapperHeight = this.$wrapper.offsetHeight;
            }
            clearAll() {
                [...this.barrageArray].forEach(b => b.destroy());
            }
        }

        const container = new BarrageContainer('#wpe-container__wrapper', '#wpe-container');
        const video = document.querySelector('#video');
        const toggleBtn = document.querySelector('#toggle-btn');
        const clearBtn = document.querySelector('#clear-btn');
        const densityInput = document.querySelector('#density');
        const densityValueEl = document.querySelector('#density-value');

        const requireChargingEl = document.querySelector('#require-charging');
        const batteryStatusEl = document.querySelector('#battery-status');

        // 0 = off, 1 = normal, higher = denser (user's desired value)
        let desiredDensity = Number(densityInput.value) || 1;

        // Battery API state
        let batteryManager = null;
        let isCharging = true; // default to "charging" if API unavailable

        function updateBatteryStatusText() {
            if (!('getBattery' in navigator)) {
                batteryStatusEl.textContent = 'Battery API: N/A';
                return;
            }
            batteryStatusEl.textContent = isCharging ? 'Charging' : 'On battery';
        }

        function effectiveDensity() {
            // If the option is enabled and the device is NOT charging, force density=1.
            if (requireChargingEl.checked && !isCharging) return 1;
            return desiredDensity;
        }

        function syncDensityUI() {
            const eff = effectiveDensity();
            densityValueEl.textContent = String(eff);
        }

        densityInput.addEventListener('input', () => {
            desiredDensity = Number(densityInput.value) || 0;
            syncDensityUI();
        });

        requireChargingEl.addEventListener('change', () => {
            syncDensityUI();
        });

        async function initBatteryWatcher() {
            if (!('getBattery' in navigator)) {
                isCharging = true;
                updateBatteryStatusText();
                syncDensityUI();
                return;
            }

            try {
                batteryManager = await navigator.getBattery();
                isCharging = Boolean(batteryManager.charging);
                updateBatteryStatusText();
                syncDensityUI();

                batteryManager.addEventListener('chargingchange', () => {
                    isCharging = Boolean(batteryManager.charging);
                    updateBatteryStatusText();
                    syncDensityUI();
                });
            } catch {
                // If permission/availability fails, behave as if charging so the feature doesn't block.
                isCharging = true;
                batteryStatusEl.textContent = 'Battery API: error';
                syncDensityUI();
            }
        }

        // init UI
        updateBatteryStatusText();
        syncDensityUI();
        initBatteryWatcher();

        function generateRandomText() {
            const phrases = ['666666', 'WOW', 'LOL', 'OMG!!!', 'ðŸ”¥ðŸ”¥ðŸ”¥', 'Subscribed', 'Wait...', 'LUL', 'Epic', '2333333', 'PogChamp', 'Hype!'];
            return phrases[Math.floor(Math.random() * phrases.length)];
        }

        function startSpawning() {
            if (video.timer) clearInterval(video.timer);
            video.timer = setInterval(() => {
                if (!container.isEnabled) return; // Don't spawn if disabled
                if (video.paused) return;

                const spawnDensity = effectiveDensity();
                if (spawnDensity <= 0) return;

                const baseCount = Math.floor(Math.random() * 5) + 8; // 8..12
                // Scale by density and clamp to protect performance
                const count = Math.min(200, Math.max(0, Math.round(baseCount * spawnDensity)));

                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        // Re-check at spawn time in case charging state/option changes
                        const dNow = effectiveDensity();
                        if (container.isEnabled && !video.paused && dNow > 0) {
                            new Barrage({ text: generateRandomText() }).append(container);
                        }
                    }, Math.random() * 400);
                }
            }, 300);
        }

        // --- BUTTON LOGIC ---

        toggleBtn.onclick = () => {
            container.isEnabled = !container.isEnabled;
            const el = document.querySelector('#wpe-container');
            if (container.isEnabled) {
                el.classList.remove('danmaku-hidden');
                toggleBtn.textContent = "Disable Danmaku";
                toggleBtn.style.background = "#535c68";
            } else {
                el.classList.add('danmaku-hidden');
                toggleBtn.textContent = "Enable Danmaku";
                toggleBtn.style.background = "#2ecc71";
            }
        };

        clearBtn.onclick = () => container.clearAll();

        video.onplay = () => startSpawning();
        video.onpause = () => clearInterval(video.timer);

        document.querySelector('#wpe-manage-btn').onclick = () => {
            const input = document.querySelector('#wpe-manage-input');
            if(!input.value) return;
            new Barrage({ text: input.value }).append(container);
            input.value = '';
        };

        document.querySelector('#fullscreen-btn').onclick = () => {
            const wrapper = document.querySelector('#wpe-container__wrapper');
            if (!document.fullscreenElement) wrapper.requestFullscreen();
            else document.exitFullscreen();
        };

        window.addEventListener('resize', () => container.updateSize());
    </script>
</body>
</html>